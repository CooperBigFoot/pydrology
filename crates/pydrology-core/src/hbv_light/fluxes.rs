//! HBV-Light model flux outputs.
//!
//! `Fluxes` holds a single timestep (returned by `step()`).
//! `FluxesTimeseries` is auto-generated by the `Fluxes` derive macro.
//! `ZoneOutputs` holds per-zone details for multi-zone runs (manual, not derived).

use pydrology_macros::Fluxes;
use crate::traits::FluxesTimeseriesOps;

/// Single-timestep fluxes.
#[derive(Debug, Clone, Copy, Fluxes)]
pub struct Fluxes {
    pub precip: f64,
    pub temp: f64,
    pub pet: f64,
    pub precip_rain: f64,
    pub precip_snow: f64,
    pub snow_pack: f64,
    pub snow_melt: f64,
    pub liquid_water_in_snow: f64,
    pub snow_input: f64,
    pub soil_moisture: f64,
    pub recharge: f64,
    pub actual_et: f64,
    pub upper_zone: f64,
    pub lower_zone: f64,
    pub q0: f64,
    pub q1: f64,
    pub q2: f64,
    pub percolation: f64,
    pub qgw: f64,
    pub streamflow: f64,
}

impl FluxesTimeseriesOps<Fluxes> for FluxesTimeseries {
    fn with_capacity(n: usize) -> Self {
        FluxesTimeseries::with_capacity(n)
    }
    fn push(&mut self, f: &Fluxes) {
        FluxesTimeseries::push(self, f);
    }
    fn len(&self) -> usize {
        FluxesTimeseries::len(self)
    }
    fn is_empty(&self) -> bool {
        FluxesTimeseries::is_empty(self)
    }
    fn with_len(n: usize) -> Self {
        FluxesTimeseries::with_len(n)
    }
    unsafe fn write_unchecked(&mut self, t: usize, f: &Fluxes) {
        unsafe { FluxesTimeseries::write_unchecked(self, t, f); }
    }
}

/// Per-zone outputs for multi-zone runs.
///
/// Flat vectors: index = t * n_zones + zone_idx (row-major).
#[derive(Debug)]
pub struct ZoneOutputs {
    pub zone_elevations: Vec<f64>,
    pub zone_fractions: Vec<f64>,
    pub n_timesteps: usize,
    pub n_zones: usize,
    /// zone_temp[t * n_zones + zone_idx]
    pub zone_temp: Vec<f64>,
    pub zone_precip: Vec<f64>,
    pub snow_pack: Vec<f64>,
    pub liquid_water_in_snow: Vec<f64>,
    pub snow_melt: Vec<f64>,
    pub snow_input: Vec<f64>,
    pub soil_moisture: Vec<f64>,
    pub recharge: Vec<f64>,
    pub actual_et: Vec<f64>,
}

impl ZoneOutputs {
    /// Pre-allocate for `n_timesteps` timesteps and `n_zones` zones.
    pub fn with_capacity(n_timesteps: usize, n_zones: usize) -> Self {
        let total = n_timesteps * n_zones;
        Self {
            zone_elevations: Vec::new(),
            zone_fractions: Vec::new(),
            n_timesteps,
            n_zones,
            zone_temp: vec![0.0; total],
            zone_precip: vec![0.0; total],
            snow_pack: vec![0.0; total],
            liquid_water_in_snow: vec![0.0; total],
            snow_melt: vec![0.0; total],
            snow_input: vec![0.0; total],
            soil_moisture: vec![0.0; total],
            recharge: vec![0.0; total],
            actual_et: vec![0.0; total],
        }
    }
}
