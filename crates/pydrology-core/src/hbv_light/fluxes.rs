//! HBV-Light model flux outputs.
//!
//! `Fluxes` holds a single timestep (returned by `step()`).
//! `FluxesTimeseries` is auto-generated by the `Fluxes` derive macro.
//! `ZoneOutputs` holds per-zone details for multi-zone runs (manual, not derived).

use pydrology_macros::Fluxes;
use crate::traits::FluxesTimeseriesOps;

/// Single-timestep fluxes.
#[derive(Debug, Clone, Copy, Fluxes)]
pub struct Fluxes {
    pub precip: f64,
    pub temp: f64,
    pub pet: f64,
    pub precip_rain: f64,
    pub precip_snow: f64,
    pub snow_pack: f64,
    pub snow_melt: f64,
    pub liquid_water_in_snow: f64,
    pub snow_input: f64,
    pub soil_moisture: f64,
    pub recharge: f64,
    pub actual_et: f64,
    pub upper_zone: f64,
    pub lower_zone: f64,
    pub q0: f64,
    pub q1: f64,
    pub q2: f64,
    pub percolation: f64,
    pub qgw: f64,
    pub streamflow: f64,
}

impl FluxesTimeseriesOps<Fluxes> for FluxesTimeseries {
    fn with_capacity(n: usize) -> Self {
        FluxesTimeseries::with_capacity(n)
    }
    fn push(&mut self, f: &Fluxes) {
        FluxesTimeseries::push(self, f);
    }
    fn len(&self) -> usize {
        FluxesTimeseries::len(self)
    }
    fn is_empty(&self) -> bool {
        FluxesTimeseries::is_empty(self)
    }
}

/// Per-zone outputs for multi-zone runs.
///
/// 2D vectors: outer index is timestep, inner index is zone.
#[derive(Debug)]
pub struct ZoneOutputs {
    pub zone_elevations: Vec<f64>,
    pub zone_fractions: Vec<f64>,
    /// zone_temp[timestep][zone]
    pub zone_temp: Vec<Vec<f64>>,
    pub zone_precip: Vec<Vec<f64>>,
    pub snow_pack: Vec<Vec<f64>>,
    pub liquid_water_in_snow: Vec<Vec<f64>>,
    pub snow_melt: Vec<Vec<f64>>,
    pub snow_input: Vec<Vec<f64>>,
    pub soil_moisture: Vec<Vec<f64>>,
    pub recharge: Vec<Vec<f64>>,
    pub actual_et: Vec<Vec<f64>>,
}

impl ZoneOutputs {
    /// Pre-allocate for `n_timesteps` timesteps and `n_zones` zones.
    pub fn with_capacity(n_timesteps: usize, n_zones: usize) -> Self {
        let alloc_2d = || {
            let mut outer = Vec::with_capacity(n_timesteps);
            for _ in 0..n_timesteps {
                outer.push(vec![0.0; n_zones]);
            }
            outer
        };
        Self {
            zone_elevations: Vec::new(),
            zone_fractions: Vec::new(),
            zone_temp: alloc_2d(),
            zone_precip: alloc_2d(),
            snow_pack: alloc_2d(),
            liquid_water_in_snow: alloc_2d(),
            snow_melt: alloc_2d(),
            snow_input: alloc_2d(),
            soil_moisture: alloc_2d(),
            recharge: alloc_2d(),
            actual_et: alloc_2d(),
        }
    }
}
